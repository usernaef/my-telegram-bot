import logging
import asyncio
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ChatPermissions
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
from telegram.error import TelegramError
from fastapi import FastAPI, Request
import os
from typing import Dict, Set
import sqlite3
import re

# ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÙˆÙ„ÛŒÙ‡
TOKEN = os.getenv('TOKEN')
PORT = int(os.getenv('PORT', '8080'))
RENDER_URL = os.getenv('RENDER_URL')

app = FastAPI()
application = Application.builder().token(TOKEN).build()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Ø¯ÛŒØªØ§Ø¨ÛŒØ³
def init_db():
    conn = sqlite3.connect('bot.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS groups
                 (group_id TEXT PRIMARY KEY, admin_id INTEGER, 
                  welcome_msg TEXT, anti_spam INTEGER DEFAULT 0, 
                  anti_link INTEGER DEFAULT 0, max_warn INTEGER DEFAULT 3, 
                  locked INTEGER DEFAULT 0)''')
    c.execute('''CREATE TABLE IF NOT EXISTS warnings
                 (user_id INTEGER, group_id TEXT, warnings INTEGER DEFAULT 0,
                  PRIMARY KEY (user_id, group_id))''')
    conn.commit()
    conn.close()

# Ú©Ø´ Ù…ÙˆÙ‚Øª
spam_cache: Dict[str, Dict[int, list]] = {}
user_messages: Dict[str, Dict[int, int]] = {}
warned_users: Dict[str, Set[int]] = {}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("â• Ø«Ø¨Øª Ú¯Ø±ÙˆÙ‡", callback_data='register_group')],
        [InlineKeyboardButton("ğŸ“š Ø±Ø§Ù‡Ù†Ù…Ø§", callback_data='help')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "Ø³Ù„Ø§Ù…! Ø¨Ù‡ Ø±Ø¨Ø§Øª Ù…Ø¯ÛŒØ±ÛŒØª Ú¯Ø±ÙˆÙ‡ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯.\n"
        "Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ØŒ Ú¯Ø±ÙˆÙ‡ Ø®ÙˆØ¯ Ø±Ø§ Ø«Ø¨Øª Ú©Ù†ÛŒØ¯ Ùˆ Ø±Ø¨Ø§Øª Ø±Ø§ Ø§Ø¯Ù…ÛŒÙ† Ú©Ù†ÛŒØ¯.",
        reply_markup=reply_markup
    )

async def register_group_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if not query.message.chat.type == 'private':
        await query.message.reply_text("Ù„Ø·ÙØ§ Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± Ø±Ø§ Ø¯Ø± Ú†Øª Ø®ØµÙˆØµÛŒ Ø§Ø¬Ø±Ø§ Ú©Ù†ÛŒØ¯.")
        return
        
    context.user_data['waiting_for_group'] = True
    await query.message.reply_text("Ù„Ø·ÙØ§Ù‹ Ø±Ø¨Ø§Øª Ø±Ø§ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡ Ø®ÙˆØ¯ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù‡ Ùˆ Ø³Ù¾Ø³ Ø¯Ø³ØªÙˆØ± /panel Ø±Ø§ Ø¯Ø± Ú¯Ø±ÙˆÙ‡ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.")

async def check_admin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id
    
    try:
        member = await context.bot.get_chat_member(chat_id, user_id)
        return member.status in ['administrator', 'creator']
    except TelegramError:
        return False

async def handle_group_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.effective_chat:
        return
        
    chat_id = str(update.effective_chat.id)
    user_id = update.effective_user.id
    
    # Ø¨Ø±Ø±Ø³ÛŒ Ø¶Ø¯ Ø§Ø³Ù¾Ù…
    await handle_spam(update, context)
    
    # Ø¨Ø±Ø±Ø³ÛŒ Ø¶Ø¯ Ù„ÛŒÙ†Ú© 
    await handle_link(update, context)
    
    # Ø¨Ø±Ø±Ø³ÛŒ Ù¾ÛŒØ§Ù… Ø®ÙˆØ´â€ŒØ¢Ù…Ø¯ Ø¨Ø±Ø§ÛŒ Ø§Ø¹Ø¶Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
    if update.message.new_chat_members:
        conn = sqlite3.connect('bot.db')
        c = conn.cursor()
        c.execute("SELECT welcome_msg FROM groups WHERE group_id=?", (chat_id,))
        result = c.fetchone()
        conn.close()
        
        if result and result[0]:
            for member in update.message.new_chat_members:
                welcome_text = result[0].replace("{user}", member.first_name)
                await update.message.reply_text(welcome_text)

async def show_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_admin(update, context):
        await update.message.reply_text("ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ†â€ŒÙ‡Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ Ø¨Ù‡ Ù¾Ù†Ù„ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù†Ø¯.")
        return
        
    keyboard = [
        [
            InlineKeyboardButton("ğŸ”’ Ù‚ÙÙ„ Ú¯Ø±ÙˆÙ‡", callback_data='lock_group'),
            InlineKeyboardButton("ğŸ“ Ù¾ÛŒØ§Ù… Ø®ÙˆØ´â€ŒØ¢Ù…Ø¯", callback_data='welcome')
        ],
        [
            InlineKeyboardButton("âš”ï¸ Ø¶Ø¯ Ø§Ø³Ù¾Ù…", callback_data='anti_spam'),
            InlineKeyboardButton("ğŸ”— Ø¶Ø¯ Ù„ÛŒÙ†Ú©", callback_data='anti_link')
        ],
        [
            InlineKeyboardButton("âš ï¸ Ø§Ø®Ø·Ø§Ø±Ù‡Ø§", callback_data='warnings'),
            InlineKeyboardButton("ğŸ‘¥ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†", callback_data='users')
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Ù¾Ù†Ù„ Ù…Ø¯ÛŒØ±ÛŒØª Ú¯Ø±ÙˆÙ‡:", reply_markup=reply_markup)

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if not await check_admin(update, context):
        await query.message.reply_text("ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ†â€ŒÙ‡Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ Ø§Ø² Ø§ÛŒÙ† Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†Ù†Ø¯.")
        return
        
    chat_id = str(query.message.chat.id)
    
    if query.data == 'lock_group':
        conn = sqlite3.connect('bot.db')
        c = conn.cursor()
        c.execute("SELECT locked FROM groups WHERE group_id=?", (chat_id,))
        result = c.fetchone()
        current_state = result[0] if result else 0
        new_state = 1 - current_state
        
        try:
            permissions = ChatPermissions(
                can_send_messages=not new_state,
                can_send_media_messages=not new_state,
                can_send_other_messages=not new_state
            )
            await context.bot.set_chat_permissions(query.message.chat_id, permissions)
            
            c.execute("UPDATE groups SET locked=? WHERE group_id=?", 
                     (new_state, chat_id))
            conn.commit()
            
            status = "Ù‚ÙÙ„" if new_state else "Ø¨Ø§Ø²"
            await query.message.reply_text(f"Ú¯Ø±ÙˆÙ‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª {status} Ø´Ø¯!")
            
        except TelegramError as e:
            await query.message.reply_text(f"Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ù‚ÙÙ„ Ú¯Ø±ÙˆÙ‡: {str(e)}")
        
        conn.close()

async def setup_webhook():
    if RENDER_URL:
        webhook_url = f"https://{RENDER_URL}/{TOKEN}"
        await application.bot.set_webhook(webhook_url)
        logger.info(f"Webhook set to {webhook_url}")
    else:
        logger.warning("RENDER_URL not set")

@app.post(f"/{TOKEN}")
async def webhook_handler(request: Request):
    data = await request.json()
    update = Update.de_json(data, application.bot)
    await application.process_update(update)
    return {"ok": True}

@app.on_event("startup")
async def startup_event():
    init_db()
    await application.initialize()
    await setup_webhook()
    
    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("panel", show_panel))
    application.add_handler(CallbackQueryHandler(handle_callback))
    application.add_handler(MessageHandler(
        filters.ChatType.GROUPS & ~filters.COMMAND,
        handle_group_message
    ))
    
    logger.info("Bot started successfully!")

@app.on_event("shutdown")
async def shutdown_event():
    await application.shutdown()
    logger.info("Bot shutdown successfully!")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=PORT)